/** *******************************************************
 * PeTRA - University of Applied Sciences Karlsruhe
 * Module : ROS2-Node "PeTRACentralControl"
 * Purpose : Base for all BT-Actions with a ROS2-Server client
 *
 * @author Moritz Weisenb√∂hler
 * @author Andreas Zachariae
 * @since 1.0.0 (2020.08.26)
 *********************************************************/
#pragma once

#include <petra_central_control/default.h>

#include <memory>

#include <rclcpp_action/rclcpp_action.hpp>

#include <petra_central_control/actions/base/Action.h>

/**
 * ROSService provides an interface to use a ROS2-Service client in a BT-Action. 
 * Template type has to be a (custom) .srv type generated by ROS2.
 */
template <typename ServiceT>
class RosService : public Action
{
public:
    using RequestT = typename ServiceT::Request;
    using ResponseT = typename ServiceT::Response;

    RosService(const std::string &name, const BT::NodeConfiguration &config) : Action(name, config)
    {
        progress_.steps = 2;
    }

    /**
     * Override and return unique ROS2-Service name. 
     * This has to be the same as the ROS2-Service server name.
     */
    virtual std::string serviceName() = 0;

    /**
     * This is called before the goal is sent asynchronously to the ROS2-Service server. 
     * @param request Request-section data of the .srv file
     */
    virtual void onSend(std::shared_ptr<RequestT> request) = 0;

    /**
     * This is called if the ROS2-Service server has finished. 
     * @param request Request-section data of the .srv file
     * @param response Response-section data of the .srv file
     */
    virtual void onResult(std::shared_future<std::shared_ptr<ResponseT>> response, std::shared_ptr<RequestT> request) = 0;

private:
    Progress progress_;

    std::shared_ptr<rclcpp::Client<ServiceT>> client_;
    std::shared_ptr<RequestT> request_;
    std::shared_future<std::shared_ptr<ResponseT>> response_;

    BT::NodeStatus onStart() override
    {
        log("Connecting to service: " + serviceName());

        progress_.current_step = 0;

        client_ = RosNode::get_node_handle()->create_client<ServiceT>(serviceName());

        return BT::NodeStatus::RUNNING;
    }

    BT::NodeStatus onRunning() override
    {
        switch (progress_.current_step)
        {
        case Progress::FAIL_STEP:
            return BT::NodeStatus::FAILURE;
        case 0:
            if (client_->service_is_ready())
            {
                send_();
            }
            break;
        case 2:
            return BT::NodeStatus::SUCCESS;
        }

        return BT::NodeStatus::RUNNING;
    }

    void onHalted() override
    {
    }

    void send_()
    {
        request_ = std::make_shared<RequestT>();

        onSend(request_);

        response_ = client_->async_send_request(request_, [this](std::shared_future<std::shared_ptr<ResponseT>>) {
            onResult(response_, request_);

            progress_.next_step("Response received.");
        });

        progress_.next_step("Request sent.");
    }
};